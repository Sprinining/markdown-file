
## 链表简单题

### [面试题 02.03. 删除中间节点](https://leetcode.cn/problems/delete-middle-node-lcci/)

```c
void deleteNode(struct ListNode *node) {
    // 转换成删除下一个节点
    node->val = node->next->val;
    node->next = node->next->next;
}
```

### [1290. 二进制链表转整数](https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/)

```c
int getDecimalValue(struct ListNode *head) {
    struct ListNode *cur = head;
    int res = 0;
    while (cur != NULL) {
        res <<= 1;
        res += cur->val;
        cur = cur->next;
    }
    return res;
}
```

### [面试题 02.02. 返回倒数第 k 个节点](https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/)

```c
int kthToLast(struct ListNode *head, int k) {
    struct ListNode *fast = head;
    struct ListNode *slow = head;
    // 快指针先走k步
    while (k > 0) {
        fast = fast->next;
        k--;
    }
    // 快慢指针同时走
    while (fast != NULL) {
        fast = fast->next;
        slow = slow->next;
    }
    return slow->val;
}
```

### [LCR 024. 反转链表](https://leetcode.cn/problems/UHnkqh/)

```c
// 迭代
struct ListNode *reverseList(struct ListNode *head) {
    struct ListNode *pre = NULL;
    struct ListNode *next;
    struct ListNode *cur = head;

    // 原地反转
    while (cur != NULL) {
        next = cur->next;
        cur->next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```

```c
// 递归
struct ListNode *reverseList(struct ListNode *head) {
    // 递归出口
    if (head == NULL || head->next == NULL) return head;
    // 递归式
    struct ListNode *newHead = reverseList(head->next); // 递归反转后面的链表
    head->next->next = head; // 下个结点也就是反转后的尾节点，指向自己
    head->next = NULL; // 自己作为新的尾节点
    return newHead;
}
```

### [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

```c
// 返回向上取整的中间节点
struct ListNode *middleNode(struct ListNode *head) {
    struct ListNode *fast = head;
    struct ListNode *slow = head;
    // 慢指针每走一步，快指针走两步
    while (fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }
    return slow;
}
```

### [LCR 023. 相交链表](https://leetcode.cn/problems/3u1WK4/)

```c
// 返回两个单链表相交的起始节点
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    int len1 = 0, len2 = 0;
    struct ListNode *p = headA, *q = headB;
    // 求长度
    while (p != NULL) {
        len1++;
        p = p->next;
    }
    while (q != NULL) {
        len2++;
        q = q->next;
    }

    // 长链表先走
    p = headA;
    q = headB;
    if (len1 > len2)
        for (int i = 0; i < len1 ### len2; ++i)
            p = p->next;
    else
        for (int i = 0; i < len2 ### len1; ++i)
            q = q->next;
    // p、q距离尾节点距离相同时，同时出发    
    while (p != NULL) {
        if (p == q)return p;
        p = p->next;
        q = q->next;
    }
    return NULL;
}
```

### [面试题 02.01. 移除重复节点](https://leetcode.cn/problems/remove-duplicate-node-lcci/)

```c
// 散列
struct ListNode *removeDuplicateNodes(struct ListNode *head) {
    if (head == NULL || head->next == NULL) return head; // 特殊情况单独处理
    int hash[20001]; // 记录是否出现过
    memset(hash, 0, sizeof(hash));
    struct ListNode *p = head;
    hash[head->val] = 1;

    // 判断当前下个节点是否需要删除
    while (p != NULL && p->next != NULL) {
        if (hash[p->next->val] == 0) {
            // 首次出现
            hash[p->next->val] = 1;
            // 指针后移
            p = p->next;
        } else {
            // 删除已经出现过
            p->next = p->next->next;
            // 指针无需后移
        }
    }
    return head;
}
```

```c
// 不使用散列
// 删除链表中所有值为k的节点
struct ListNode *removeNode(struct ListNode *head, int k) {
    struct ListNode *headNode = (struct ListNode *) malloc(sizeof(struct ListNode));
    headNode->next = head;
    struct ListNode *p = headNode;

    while (p != NULL && p->next != NULL) {
        if (p->next->val == k) {
            // 跳过节点
            p->next = p->next->next;
            // 指针无需后移
        } else {
            // 指针后移
            p = p->next;
        }
    }

    return headNode->next;
}

struct ListNode *removeDuplicateNodes(struct ListNode *head) {
    if (head == NULL || head->next == NULL) return head; // 特殊情况单独处理
    struct ListNode *cur = head;
    while (cur != NULL && cur->next != NULL) {
        // 删除后续链表中和当前值相同的所有节点
        cur->next = removeNode(cur->next, cur->val);
        cur = cur->next;
    }
    return head;
}
```

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```c
// 合并升序链表（迭代）
struct ListNode *mergeTwoLists(struct ListNode *list1, struct ListNode *list2) {
    struct ListNode *head = (struct ListNode*)malloc(sizeof(struct ListNode));
    head->next = NULL; // 写完成，不然if (list1 != NULL)会报错
    struct ListNode *p = head;
    // 从两个链表中反复选出较小者
    while (list1 != NULL && list2 != NULL) {
        if (list1->val < list2->val) {
            p->next = list1;
            list1 = list1->next;
        } else {
            p->next = list2;
            list2 = list2->next;
        }
        p = p->next;
    }
    // 把剩余的链表直接接上
    if (list1 != NULL) p->next = list1;
    if (list2 != NULL) p->next = list2;

    return head->next;
}
```

```c
// 递归
struct ListNode *mergeTwoLists(struct ListNode *list1, struct ListNode *list2) {
    // 递归出口
    if (list1 == NULL) return list2;
    if (list2 == NULL) return list1;
    // 递归体
    if (list1->val < list2->val) {
        list1->next = mergeTwoLists(list1->next, list2);
        return list1;
    } else {
        list2->next = mergeTwoLists(list1, list2->next);
        return list2;
    }
}
```

### [LCR 027. 回文链表](https://leetcode.cn/problems/aMhZSa/)

```c
// 返回向上取整的中间节点
struct ListNode *findMid(struct ListNode *head) {
    struct ListNode *slow = head;
    struct ListNode *fast = head;
    while (fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }
    return slow;
}

// 原地反转
struct ListNode *reverseList(struct ListNode *head) {
    struct ListNode *pre = NULL;
    struct ListNode *cur = head;
    struct ListNode *next;
    while (cur != NULL) {
        next = cur->next;
        cur->next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}


bool isPalindrome(struct ListNode *head) {
    struct ListNode *mid = findMid(head);
    mid = reverseList(mid);

    struct ListNode *p = head;
    struct ListNode *q = mid;
    while (q != NULL) {
        if (p->val != q->val) return false;
        p = p->next;
        q = q->next;
    }
    return true;
}
```

### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```c
// 删除链表中所有值为k的节点
struct ListNode *removeElements(struct ListNode *head, int val) {
    struct ListNode *headNode = (struct ListNode *) malloc(sizeof(struct ListNode));
    headNode->next = head;
    struct ListNode *p = headNode;

    while (p != NULL && p->next != NULL) {
        if (p->next->val == val) {
            // 跳过节点
            p->next = p->next->next;
            // 指针无需后移
        } else {
            // 指针后移
            p = p->next;
        }
    }

    return headNode->next;
}
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```c
bool hasCycle(struct ListNode *head) {
    if (head == NULL || head->next == NULL) return false;

    struct ListNode *slow = head;
    struct ListNode *fast = head->next;
    // 快慢指针，若有环，快指针迟早会追过慢指针（多跑了一个环的距离）
    while (fast != NULL && fast->next != NULL) {
        if (slow == fast)return true;
        slow = slow->next;
        fast = fast->next->next;
    }
    return false;
}
```

## 链表反转

### 反转全部

```c
// 迭代
struct ListNode *reverseList(struct ListNode *head) {
    struct ListNode *pre = NULL;
    struct ListNode *next;
    struct ListNode *cur = head;

    // 原地反转
    while (cur != NULL) {
        next = cur->next;
        cur->next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```

```c
// 递归
struct ListNode *reverseList(struct ListNode *head) {
    // 递归出口
    if (head == NULL || head->next == NULL) return head;
    // 递归式
    struct ListNode *newHead = reverseList(head->next); // 递归反转后面的链表
    head->next->next = head; // 下个结点也就是反转后的尾节点，指向自己
    head->next = NULL; // 自己作为新的尾节点
    return newHead;
}
```

### 反转前n个

```c
// 第n个节点的直接后继
struct ListNode *successor = nullptr;

// 反转前n个节点(递归)
struct ListNode *reverseListFront(struct ListNode *head, int n) {
    if (head == nullptr || head->next == nullptr) return head;
    if (n == 1) {
        // 记录下原来顺序中第n+1个节点
        successor = head;
        return head;
    }

    // 反转后面n-1个节点
    ListNode *newHead = reverseListFront(head->next, n ### 1);
    // 添加到反转后的n-1个节点的最后面
    head->next->next = head;
    // 反转全部链表时，这里是null；反转前n个时，这里是原链表中第n+1个节点
    head->next = successor;
    return newHead;
}
```

### 反转中间

```c
// 反转[start, end]，下标从1开始
struct ListNode *reverseListMid(struct ListNode *head, int start, int end) {
    // 递归出口：反转前end个
    if (start == 1) return reverseListFront(head, end);
    // 递归体：反转以head.next为头节点的链表
    head->next = reverseListMid(head->next, start ### 1, end ### 1);
}
```

## 哈希表

### [705. 设计哈希集合](https://leetcode.cn/problems/design-hashset/)

```c
// 拉链法
struct ListNode {
    int val;
    struct ListNode *next;
};

typedef struct {
    struct ListNode *data;
} MyHashSet;

// 模
const int hashSize = 1009;

MyHashSet *myHashSetCreate() {
    MyHashSet *myHashSet = (MyHashSet *) malloc(sizeof(MyHashSet));
    myHashSet->data = (struct ListNode *) malloc(sizeof(struct ListNode) * (hashSize + 1));
    for (int i = 0; i <= hashSize; ++i) {
        myHashSet->data[i].val = -1;
        myHashSet->data[i].next = NULL;
    }
    return myHashSet;
}

// 散列
int hash(int key) {
    return key % hashSize;
}

struct ListNode *getList(MyHashSet *obj, int key) {
    return &(obj->data[hash(key)]);
}

// 返回查找的节点
struct ListNode *findNode(struct ListNode *head, int key) {
    struct ListNode *p = head;
    while (p != NULL && p->next != NULL) {
        if (p->next->val == key) return p;
        p = p->next;
    }
    return NULL;
}

bool containsNode(struct ListNode *head, int key) {
    return findNode(head, key) != NULL;
}

void insertNode(struct ListNode *head, int key) {
    struct ListNode *node = (struct ListNode *) malloc(sizeof(struct ListNode));
    node->val = key;
    node->next = head->next;
    head->next = node;
}

void removeNode(struct ListNode *head, int key) {
    struct ListNode *p = head;
    while (p != NULL && p->next != NULL) {
        // 如果存在也只会有一个节点
        if (p->next->val == key){
            p->next = p->next->next;
            return;
        } 
        p = p->next;
    }
}

void myHashSetAdd(MyHashSet *obj, int key) {
    struct ListNode *head = getList(obj, key);
    if (containsNode(head, key)) return;
    insertNode(head, key);
}

void myHashSetRemove(MyHashSet *obj, int key) {
    struct ListNode *head = getList(obj, key);
    if (!containsNode(head, key)) return;
    removeNode(head, key);
}

bool myHashSetContains(MyHashSet *obj, int key) {
    struct ListNode *head = getList(obj, key);
    return containsNode(head, key);
}

void myHashSetFree(MyHashSet *obj) {
    if (obj != NULL) {
        if (obj->data != NULL) {
            free(obj->data);
            obj->data = NULL;
        }
        free(obj);
        obj = NULL;
    }
}
```

### [706. 设计哈希映射](https://leetcode.cn/problems/design-hashmap/)

```c
// 拉链法
struct MyListNode {
    int key;
    int value;
    struct MyListNode *next;
};

typedef struct {
    struct MyListNode *data;
} MyHashMap;

const int hashSize = 1009;

MyHashMap *myHashMapCreate() {
    MyHashMap *myHashMap = (MyHashMap *) malloc(sizeof(MyHashMap));
    myHashMap->data = (struct MyListNode *) malloc(sizeof(struct MyListNode) * (hashSize + 1));
    for (int i = 0; i <= hashSize; ++i) {
        myHashMap->data[i].key = -1;
        myHashMap->data[i].next = NULL;
    }
    return myHashMap;
}

int hash(int key) {
    return key % hashSize;
}

struct MyListNode *getList(MyHashMap *obj, int key) {
    return &(obj->data[hash(key)]);
}

struct MyListNode *findNode(struct MyListNode *head, int key) {
    while (head != NULL) {
        if (head->key == key)return head;
        head = head->next;
    }
    return NULL;
}

void insertNode(struct MyListNode *head, int key, int value) {
    struct MyListNode *node = (struct MyListNode *) malloc(sizeof(struct MyListNode));
    node->key = key;
    node->value = value;
    node->next = head->next;
    head->next = node;
}

void removeNode(struct MyListNode *head, int key) {
    while (head != NULL && head->next != NULL) {
        if (head->next->key == key) {
            head->next = head->next->next;
            return;
        }
        head = head->next;
    }
}

void myHashMapPut(MyHashMap *obj, int key, int value) {
    struct MyListNode *head = getList(obj, key);
    struct MyListNode *node = findNode(head, key);
    if (node == NULL) {
        insertNode(head, key, value);
    } else {
        node->value = value;
    }
}

int myHashMapGet(MyHashMap *obj, int key) {
    struct MyListNode *head = getList(obj, key);
    struct MyListNode *node = findNode(head, key);
    if (node != NULL) return node->value;
    return -1;
}

void myHashMapRemove(MyHashMap *obj, int key) {
    struct MyListNode *head = getList(obj, key);
    struct MyListNode *node = findNode(head, key);
    if (node != NULL) removeNode(head, key);
}

void myHashMapFree(MyHashMap *obj) {
    if (obj != NULL) {
        if (obj->data != NULL) {
            free(obj->data);
            obj->data = NULL;
        }
        free(obj);
        obj = NULL;
    }
}
```







## 链表中等题





